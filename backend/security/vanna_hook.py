"""Vanna integration hook for SQL query validation.

This module provides the SINGLE ENTRY POINT for validating AI-generated
SQL queries before they are executed against the database. It combines
the SqlQueryValidator, QueryAllowlist, and input sanitizer into one
cohesive validation pipeline.
"""

from __future__ import annotations

import logging
import time
from pathlib import Path

from backend.security.allowlist import QueryAllowlist
from backend.security.models import ValidatedQuery
from backend.security.sql_validator import SqlQueryValidator

logger = logging.getLogger(__name__)

# Module-level singletons (lazy-initialized)
_validator: SqlQueryValidator | None = None
_allowlist: QueryAllowlist | None = None


def _get_validator() -> SqlQueryValidator:
    """Get or create the singleton SqlQueryValidator."""
    global _validator
    if _validator is None:
        _validator = SqlQueryValidator()
    return _validator


def _get_allowlist(config_path: str | Path | None = None) -> QueryAllowlist:
    """Get or create the singleton QueryAllowlist."""
    global _allowlist
    if _allowlist is None:
        _allowlist = QueryAllowlist(config_path=config_path)
    return _allowlist


def validate_vanna_output(
    generated_sql: str,
    original_query: str = "",
    allowlist_config_path: str | Path | None = None,
) -> ValidatedQuery:
    """Validate an AI-generated SQL query before execution.

    This is the SINGLE ENTRY POINT for all Vanna SQL validation.
    It runs the following pipeline:

    1. Basic validation (empty check, parse check)
    2. SqlQueryValidator checks (forbidden ops, injection patterns,
       stacked queries, comment injection, schema probing)
    3. Allowlist checks (table and operation permissions)

    Args:
        generated_sql: The SQL query generated by Vanna/LLM.
        original_query: The original natural language query (for logging).
        allowlist_config_path: Optional path to allowed_tables.json.

    Returns:
        ValidatedQuery with is_safe, sql, reason, risk_score, and
        validation_time_ms.
    """
    start_time = time.perf_counter()

    # Empty query check
    if not generated_sql or not generated_sql.strip():
        elapsed = (time.perf_counter() - start_time) * 1000
        return ValidatedQuery(
            is_safe=False,
            sql="",
            reason="Empty SQL query generated",
            risk_score=1.0,
            validation_time_ms=elapsed,
        )

    validator = _get_validator()
    allowlist = _get_allowlist(config_path=allowlist_config_path)

    # Step 1: Run SqlQueryValidator
    result = validator.validate(generated_sql)

    if not result.is_valid:
        elapsed = (time.perf_counter() - start_time) * 1000
        reason = "; ".join(result.violations)
        logger.warning(
            "SQL validation failed for query from '%s': %s",
            original_query[:100] if original_query else "<no query>",
            reason,
        )
        return ValidatedQuery(
            is_safe=False,
            sql=generated_sql,
            reason=f"Validation failed: {reason}",
            risk_score=result.risk_score,
            validation_time_ms=elapsed,
        )

    # Step 2: Check tables against allowlist
    disallowed_tables = [
        t for t in result.tables_accessed if not allowlist.is_table_allowed(t)
    ]
    if disallowed_tables:
        elapsed = (time.perf_counter() - start_time) * 1000
        reason = f"Access to table(s) not allowed: {', '.join(disallowed_tables)}"
        logger.warning(
            "Allowlist violation for query from '%s': %s",
            original_query[:100] if original_query else "<no query>",
            reason,
        )
        return ValidatedQuery(
            is_safe=False,
            sql=generated_sql,
            reason=reason,
            risk_score=max(result.risk_score, 0.7),
            validation_time_ms=elapsed,
        )

    # Step 3: Check that the operation is allowed (SELECT only by default)
    forbidden_ops = validator.contains_forbidden_operations(generated_sql)
    # At this point forbidden_ops should be empty (caught in Step 1),
    # but double-check the allowlist for the primary operation type
    if not forbidden_ops and result.sanitized_sql:
        primary_op = result.sanitized_sql.strip().split()[0].upper()
        if not allowlist.is_operation_allowed(primary_op):
            elapsed = (time.perf_counter() - start_time) * 1000
            reason = f"Operation '{primary_op}' is not in the allowlist"
            logger.warning(
                "Operation not allowed for query from '%s': %s",
                original_query[:100] if original_query else "<no query>",
                reason,
            )
            return ValidatedQuery(
                is_safe=False,
                sql=generated_sql,
                reason=reason,
                risk_score=max(result.risk_score, 0.6),
                validation_time_ms=elapsed,
            )

    # All checks passed
    elapsed = (time.perf_counter() - start_time) * 1000
    logger.debug(
        "SQL validation passed (%.2fms, risk=%.2f, tables=%s)",
        elapsed,
        result.risk_score,
        result.tables_accessed,
    )

    return ValidatedQuery(
        is_safe=True,
        sql=result.sanitized_sql,
        reason="Query passed all validation checks",
        risk_score=result.risk_score,
        validation_time_ms=elapsed,
    )


def reset_singletons() -> None:
    """Reset module-level singletons. Useful for testing."""
    global _validator, _allowlist
    _validator = None
    _allowlist = None
